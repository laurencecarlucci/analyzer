//===========Program to plot TDC and ADC data from root trees by Davison, Hesse, Losasda, Kerver Brash==========
#include <iostream>
#include <fstream>

//Global Variables
bool remakepedfile= true;
const int bin = 100; 
const Int_t Nadc = 16;
const Int_t Ntdc = 16;
const Int_t pedrun = 172;
const Int_t bl=Ntdc-16+0;//Start at channel 0
const Int_t br=Ntdc-16+1;
const Int_t tl=Ntdc-16+2;
const Int_t tr=Ntdc-16+3;
const Double_t adjadcto=1500.0;//value to ADJust ADC TO
Double_t nscint = 1.50; // index of refraction of scintillator
Double_t vn = 2.997E08/nscint;
Double_t dscint = 0.105; // distance between scintillators in metres
Double_t t_fullscale = 140.0E-09; // full scale TDC range in seconds
Double_t t_convert=t_fullscale/4096.0;
Double_t granularity = t_convert*vn/2.0;
Double_t xpos_range = 0.30;
const int xposbin = 2.0*xpos_range/granularity;



//=============================================Method starts here for plotting===================================

void luterplots(Int_t nrun) {

//create new pedestal values


	Char_t *tdcnames[Ntdc]={"Bottom Left","Bottom Right","Top Left","Top Right","4","5","6","7","8","9","10","11","12","13","14","15"};	
	char *adcnames[Nadc]={"Bottom Left","Bottom Right","Top Left","Top Right","4","5","6","7","8","9","10","11","12","13","14","15"};


//Set correction values
    Double_t tdccorrect[Ntdc];
    Double_t ped[Nadc];
    Double_t gain[Nadc];

	
//Read files and tree branches 
	gStyle->SetOptStat(1);
	TFile *froot =  new TFile(Form("./rootfiles/test%d.root",nrun));
	TTree *troot = (TTree*)froot->Get("tdata");
	Int_t tdc[Ntdc]; 
	Int_t adc[Nadc]; 
	troot->SetBranchAddress("tdc",&tdc);
	troot->SetBranchAddress("adc",&adc);
	const int nevents_in_file = (int)troot->GetEntries();

//Create Histograms
	TH1F *htdcraw[Ntdc], *htdcadjusted[Ntdc], *hadcraw[Nadc], *hadccut[Nadc], *hadcadjusted[Nadc];
	htpos = new TH1F("htpos","Top Position",xposbin,-1.0*xpos_range,xpos_range); //Histogram for top scintillator
	hbpos = new TH1F("hbpos","Bottom Position",xposbin,-1.0*xpos_range,xpos_range); //Histogram for bottom scintillator 
	htheta = new TH1F("htheta","Angle (Degrees)",10*bin,-100.5,100.5); //Histogram for incidence angle
	hadctop = new TH1F("hadctop","Top Energy Dep",bin,0,8500);
	hadcbot = new TH1F("hadcbot","Bottom Energy Dep",bin,0,8500);
    htopLeftvXpos = new TH2F("htopLeftvXpos","corrected top left paddle ADC vs. xpos top ",100,-0.30.,0.30,50,500,2500);
    htopRightvXpos = new TH2F("htopRightvXpos","corrected top right paddle ADC vs. xpos top ",100,-0.30.,0.30,50,500,2500);
    hbotLeftvXpos = new TH2F("hbotLeftvXpos","corrected bottom left paddle ADC vs. xpos bottom ",100,-0.30.,0.30,50,500,2500);
    hbotRightvXpos = new TH2F("hbotRightvXpos","corrected bottom right paddle ADC vs. xpos bottom ",100,-0.30.,0.30,50,500,2500);
    htopadctheta = new TH2F("htopadctheta","corrected top ADC vs. theta ",1000,-60.0,60.0,200,0,4500);
    hbotadctheta = new TH2F("hbotadctheta","corrected bottom ADC vs. theta ",1000,-60.0,60.0,200,0,4500);


	for ( int i = 0; i < Ntdc ; i++) {
		htdcraw[i] = new TH1F(Form("htdcraw%02d", i),Form("%s   raw tdc",tdcnames[i]),bin,1700,2700);
        	htdcadjusted[i] = new TH1F(Form("htdcadjusted%02d", i),Form("%s   adjusted tdc",tdcnames[i]),bin,1500,2500);
	}
    
	for ( int i = 0; i < Nadc ; i++) {
        	hadcraw[i] = new TH1F(Form("hadcraw%02d", i),Form("%s   raw adc",adcnames[i]),bin,0,5500);
        	hadccut[i] = new TH1F(Form("hadccut%02d", i),Form("%s  cut adc",adcnames[i]),bin,0,5500);
        	hadcadjusted[i] = new TH1F(Form("hadcadjusted%02d", i),Form("%s   adjusted adc",adcnames[i]),bin,0,5500);
        }
    
	
//=====================================GET PED for ADC==========================
	if(remakepedfile){gROOT->ProcessLine(Form(".x luterpedestals.C(%d)",pedrun));cout<<"pedestal file made"<<endl;}
	FILE *adcpeds = fopen(Form("/home/jlabdaq/analyzer/pedestalfiles/pedestalrun%d.dat",pedrun),"r");
	for( int i = 0; i < Nadc ; i++) {//Start ADC filling loop
		fscanf(adcpeds,"%lf\n",&ped[i]);
//		printf("%lf\n",ped[i]);
	}

//=====================================GET ADJ FACTORS for ADC&TDC==========================
    for (int ie = 0; ie < nevents_in_file; ie++) {
		troot->GetEntry(ie);
		if(ie%130000==0.0&&ie!=0){cout<<"Progress: "<<((double)ie)/((double)nevents_in_file)*100<<"%"<<endl;}
		for( int i = 0; i < Ntdc ; i++) {//Start TDC filling loop
            		htdcraw[i]->Fill(tdc[i]);
		}
		for( int i = 0; i < Nadc ; i++) {//Start ADC-ADJUSTED filling loop
			hadcraw[i]->Fill(adc[i]);
			hadccut[i]->Fill(adc[i]-ped[i]);
		}//End ADC for loop
	}

	TCanvas *c1 = new TCanvas("c1","tdc raw fitter",75,75,600,600);
   	c1->Divide(2,2);
   	for ( int i = bl; i <= tr ; i++) {
      	c1->cd(i-bl+1);		
		htdcraw[i]->Draw();
//the next 7 lines allow us to automatically set the fitting range
		int highbin=5;		
		for(int ii=0;ii<=bin;ii++){
			if((htdcraw[i]->GetBinContent(ii))>(htdcraw[i]->GetBinContent(highbin))&&ii>=5){
				highbin=ii;
			}
		}
		int median = htdcraw[i]->GetBinCenter(highbin);
		htdcraw[i]->Fit("gaus","Q","",(median-200),(median+200));
		tdccorrect[i] = 2000 - (htdcraw[i]->GetFunction("gaus")->GetParameter(1));
    }
	//c1->Close(); //closes default canvas built within histo_>Fit



//==============LOOP THROUGH EVENTS IN FILE AND DO MATHS=============================
	for (int ie = 0; ie < nevents_in_file; ie++) {
		troot->GetEntry(ie);  
	//=========================================ADC===============================
        if(ie%130000==0.0&&ie!=0){cout<<"Progress: "<<((double)ie)/((double)nevents_in_file)*100<<"%"<<endl;}
		for( int i = 0; i < Nadc ; i++) {//Start ADC-ADJUSTED filling loop
			gain[i]=adjadcto/(hadccut[i]->GetMean());	 
			hadcadjusted[i]->Fill(gain[i]*(adc[i]-ped[i]));
		}//End ADC for loop
		    
		    	Double_t ebl = gain[bl]*(adc[bl]-ped[bl]);
		    	Double_t ebr = gain[br]*(adc[br]-ped[br]);
		    	Double_t etl = gain[tl]*(adc[tl]-ped[tl]);
		    	Double_t etr = gain[tr]*(adc[tr]-ped[tr]);
		
	//==========================================TDC===============================
		    
			for( int i = 0; i < Ntdc ; i++) {//Start TDC filling loop
				if(i<4){
					htdcadjusted[i]->Fill(tdc[i]+tdccorrect[i]);		
				}
				else{	
					htdcadjusted[i]->Fill(tdc[i]);
				}
			}//End TDC for loop

			Double_t tbl = tdc[bl]+tdccorrect[bl];
			Double_t tbr = tdc[br]+tdccorrect[br];
			Double_t ttl = tdc[tl]+tdccorrect[tl];
			Double_t ttr = tdc[tr]+tdccorrect[tr];
			Double_t rtod = 180.0/3.14159265;
			Double_t tdiff = (ttl-ttr)/2.0;
			Double_t bdiff = (tbl-tbr)/2.0;
			Double_t xtop = tdiff*t_convert*vn;
			Double_t xbottom = bdiff*t_convert*vn;
			Double_t theta = rtod*atan((xbottom-xtop)/dscint);

			htpos->Fill(xtop);
			hbpos->Fill(xbottom);
		    	if(abs(theta)<=85.0) htheta->Fill(theta);

			htopLeftvXpos->Fill(xtop,etl); 
			htopRightvXpos->Fill(xtop,etr); 
			hbotLeftvXpos->Fill(xbottom,ebl); 
			hbotRightvXpos->Fill(xbottom,ebr); 
		    
			htopadctheta->Fill(theta,(etl+etr)/2.0); 
			hbotadctheta->Fill(theta,(ebl+ebr)/2.0); 
			hadctop->Fill((etl+etr)/2.0); 
			hadcbot->Fill((ebl+ebr)/2.0); 
		
	} //End of loop over events

    
//=======================================Canvases=============================

//Draw TDC and ADC raw data
    
 	TCanvas *tdc_canvas = new TCanvas("tdc_canvas","TDC spectra",100,100,600,600);
   	tdc_canvas->Divide(2,2);
   	for ( int i = bl; i <= tr ; i++) {
      			tdc_canvas->cd(i-bl+1);
				hadcraw[i]->Draw();
				//hadccut[i]->Draw();
      			//htdcadjusted[i]->Draw();
	}

        TCanvas *adc_canvas = new TCanvas("adc_canvas","ADC spectra",125,125,600,600);
        adc_canvas->Divide(2,2);
        for ( int i = 0; i <= 3 ; i++) {
                		adc_canvas->cd(i+1);
				//hadcraw[i]->Draw();
				//hadccut[i]->Draw();                
				hadcadjusted[i]->Draw();
        }

 	TCanvas *adcpos = new TCanvas("adcpos","ADC vs xpos",150,150,600,600);
 
	adcpos->Divide(2,2);
	adcpos->cd(1);
	htopLeftvXpos->Draw("COLZ");
	adcpos->cd(2);
	htopRightvXpos->Draw("COLZ");
	adcpos->cd(3);
	hbotLeftvXpos->Draw("COLZ");
	adcpos->cd(4);
	hbotRightvXpos->Draw("COLZ");
 	
	TCanvas *adctheta = new TCanvas("adctheta","ADC vs theta",175,175,600,600);
 
	adctheta->Divide(2,2);
	adctheta->cd(1);
	htopadctheta->Draw("COLZ");
	adctheta->cd(2);
	hbotadctheta->Draw("COLZ");
	adctheta->cd(3);

 //use a TProfile to convert the 2-d to 1-d problem
 	TF1 *myLeBronFit = new TF1("myLeBronFit","[0]*(1.0+[1]*cos(x*3.14159/180.0))",-60.0,60.0);
	TProfile *prof = htopadctheta->ProfileX();
 	prof->Fit("myLeBronFit","QR");
	prof->Draw();
	adctheta->cd(4);
	TProfile *prof2 = hbotadctheta->ProfileX();
 	prof2->Fit("myLeBronFit","QR");
	prof2->Draw();
    
 	TCanvas *tdcpos = new TCanvas("tdcpos","X Positions",200,200,600,600);
 
	tdcpos->Divide(1,3);
	gStyle->SetOptFit(1);
	tdcpos->cd(1);
	htpos->Draw();
	tdcpos->cd(2);
	hbpos->Draw();
	tdcpos->cd(3);
	htheta->Draw();
    	TF1 *myfit = new TF1("myfit","[0]*pow(cos(x/180.0*3.14159),2)",-60,60);
    	myfit->SetParameter(0,140);
	htheta->Fit("myfit","QRW");
 	
	TCanvas *adctot = new TCanvas("adctot","Top and Bottom ADC Sums",225,225,600,600);
 
	adctot->Divide(1,2);
	gStyle->SetOptFit(1);
	adctot->cd(1);
	hadctop->Draw();
	adctot->cd(2);
	hadcbot->Draw();
 
    
}
